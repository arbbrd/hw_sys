# **sdb_01_arb**

## Задание_1_СУБД

Кейс.

Крупная строительная компания, которая также занимается проектированием и девелопментом, решила создать правильную архитектуру для работы с данными. Ниже представлены задачи, которые необходимо решить для каждой предметной области.

Какие типы СУБД, на ваш взгляд, лучше всего подойдут для решения этих задач и почему?

1. Бюджетирование проектов с дальнейшим формированием финансовых аналитических отчётов и прогнозирования рисков. СУБД должна гарантировать целостность и чёткую структуру данных.
2. Хеширование стало занимать длительно время, какое API можно использовать для ускорения работы?
3. Под каждый девелоперский проект создаётся отдельный лендинг, и все данные по лидам стекаются в CRM к маркетологам и менеджерам по продажам. Какой тип СУБД лучше использовать для        лендингов и для CRM? СУБД должны быть гибкими и быстрыми.
4. Можно ли эту задачу закрыть одной СУБД? И если да, то какой именно СУБД и какой реализацией?
5. Отдел контроля качества решил создать базу по корпоративным нормам и правилам, обучающему материалу и так далее, сформированную согласно структуре компании. СУБД должна иметь простую и понятную структуру.
6. Можно ли под эту задачу использовать уже существующую СУБД из задач выше и если да, то как лучше это реализовать?
7. Департамент логистики нуждается в решении задач по быстрому формированию маршрутов доставки материалов по объектам и распределению курьеров по маршрутам с доставкой документов. СУБД должна уметь быстро работать со связями.
8. Можно ли к этой СУБД подключить отдел закупок или для них лучше сформировать свою СУБД в связке с СУБД логистов?
9. Можно ли все перечисленные выше задачи решить, используя одну СУБД? Если да, то какую именно?

## Решение 1

1. Реляционная СУБД.
2. Попробовать простой FastAPI-сервис с оптимизацией - это даст немедленное ускорение с минимальными затратами. Если этого недостаточно - переходить к облачным HSM-решениям.
3. Лендинги: MongoDB+Redis - Гибкость, скорость разработки, хорошая производительность чтения. CRM: PostgreSQL+Redis - Целостность данных, сложные запросы, аналитика, транзакции.
4. PostgreSQL: JSONB для гибкости лендингов, реляционная модель для структуры CRM, индексы GIN для быстрого поиска по JSON, партиционирование для масштабирования, транзакции для целостности данных.
5. PostgreSQL: простая структура — таблицы соответствуют бизнес-сущностям; четкие связи — внешние ключи гарантируют целостность; легкие запросы — SQL интуитивно понятен для бизнес-пользователей; гибкость — JSONB для сложных данных + реляционная модель для структуры; масштабируемость — от маленького отдела до всей компании.
6. Существующую PostgreSQL: уже работает в продакшене для CRM и лендингов; единая точка истины - все корпоративные данные в одном месте; мощные кросс-связи между проектами, лидами и нормативами; экономия ресурсов - не нужно администрировать новую БД; схема quality изолирует новую функциональность.
7. Графовая СУБД Neo4j: естественная модель - объекты как узлы, дороги как связи; мгновенные расчеты - сложные маршруты за миллисекунды; динамическая оптимизация - адаптация к изменяющимся условиям; глубокая аналитика - анализ эффективности маршрутов и курьеров.
8. Подключить отдел закупок к той же графовой СУБД: синергия - оптимизация закупок с учетом логистики дает 20-30% экономии; единая модель - все связи между поставщиками, материалами и объектами в одном месте; проактивность - выявление рисков до срыва сроков строительства; оптимизация - автоматический выбор лучших цепочек поставок.
9. PostgreSQL.


## Задание_2_Транзакции

1. Пользователь пополняет баланс счёта телефона, распишите пошагово, какие действия должны произойти для того, чтобы транзакция завершилась успешно. Ориентируйтесь на шесть действий.
2. Какие действия должны произойти, если пополнение счёта телефона происходило бы через автоплатёж?

## Решение 2

1. Шаги для успешного пополнения баланса телефона:
- Инициация платежа. Пользователь вводит номер телефона и сумму пополнения в интерфейсе платежного сервиса (приложение банка, терминал, сайт оператора) и подтверждает операцию (например, нажатием кнопки «Оплатить»).
- Авторизация и списание средств. Платежная система (банк, электронный кошелек) проверяет реквизиты пользователя (достаточно ли средств, не заблокирована ли карта) и резервирует (списывает) указанную сумму со счета плательщика.
- Перенаправление запроса. Платежный шлюз передает информацию о транзакции (номер телефона, сумму) биллинговой системе оператора связи, которому принадлежит номер.
- Обработка и зачисление. Биллинговая система оператора идентифицирует абонента по номеру телефона, проверяет корректность запроса и зачисляет средства на его лицевой счет.
- Подтверждение успеха. Система оператора отправляет платежному шлюзу подтверждение о успешном зачислении средств. Шлюз, в свою очередь, уведомляет об этом первоначальный платежный сервис.
- Финальное уведомление. Пользователь получает визуальное подтверждение в приложении или на сайте (надпись «Оплата прошла успешно»), а также SMS-сообщение от оператора связи о пополнении счета на конкретную сумму и текущем состоянии баланса.

2. Пополнения счета через автоплатеж автоматизирован:
- Срабатывание триггера. Система оператора связи или банка в установленную дату (например, 1-го числа каждого месяца или при снижении баланса ниже 50 рублей) проверяет условия для запуска автоплатежа.
- Автоматическое создание заявки. При выполнении условий система формирует автоматический запрос на платеж: фиксирует номер телефона, сумму списания (фиксированную или для пополнения до определенного уровня) и данные привязанной банковской карты.
- Списание средств. Платежный шлюз банка получает запрос и проводит авторизацию — проверяет карту на достаточность средств, доступность для онлайн-платежей и списывает необходимую сумму.
- Передача средств и зачисление. Банк перечисляет деньги на расчетный счет оператора связи, а биллинговая система оператора мгновенно зачисляет их на баланс указанного номера телефона.
- Уведомление пользователя. Пользователь получает два ключевых сообщения: push- или SMS-уведомление от банка о успешном списании средств по автоплатежу и стандартное SMS от оператора связи о пополнении счета, с указанием суммы и нового баланса.
- Обновление статуса автоплатежа. Система, инициировавшая платеж, отмечает его как «Успешно выполнен» в истории операций, фиксирует дату и время для отчетности и готовится к следующему циклу.


## Задание_3_SQL vs NoSQL

1. Напишите пять преимуществ SQL-систем по отношению к NoSQL.
2. Какие, на ваш взгляд, преимущества у NewSQL систем перед SQL и NoSQL.

## Решение 3

1. Пять преимуществ SQL-систем по отношению к NoSQL:
- Гарантированная целостность данных и согласованность (ACID).
Это главное преимущество SQL-систем. Транзакции в реляционных базах данных соответствуют принципам ACID (Atomicity, Consistency, Isolation, Durability — Атомарность, Согласованность, Изолированность, Долговечность). Это означает, что каждая операция либо выполняется полностью, либо не выполняется вовсе, и данные всегда находятся в корректном состоянии.
Противопоставление NoSQL: Многие NoSQL-системы следуют принципу eventual consistency ( eventual consistency — конечная согласованность), где данные со временем становятся согласованными across всех узлах. Это недопустимо для финансовых операций, бронирований или любых систем, где точность данных критична.

- Мощный и стандартизированный язык запросов (SQL).
SQL — это богатый, выразительный и универсальный стандарт. Он позволяет выполнять сложные запросы, объединять данные из множества таблиц (JOIN), агрегировать их, сортировать и фильтровать с высокой эффективностью. Один запрос может заменить сотни строк императивного кода.
Противопоставление NoSQL: В NoSQL запросы часто специфичны для конкретной системы и, как правило, менее мощные. Сложные соединения и агрегации могут быть неудобными или требовать выполнения на стороне приложения, что увеличивает сложность и снижает производительность.

- Гибкость запросов без предварительного определения схемы данных.
Как ни парадоксально, но гибкость — это сила SQL. Структура данных (схема) жестко определена, но это позволяет задавать практически любые запросы к этим данным ad-hoc, не задумываясь о них на этапе проектирования. Вы можете легко получить ответ на внезапно возникший бизнес-вопрос, соединив таблицы нужным образом.
Противопоставление NoSQL: Во многих NoSQL-системах (особенно документных) структура запросов часто определяется структурой хранения данных. Если вам нужен новый способ фильтрации, может потребоваться создание нового индекса или даже изменение структуры хранения, что не всегда гибко.

- Снижение избыточности данных за счет нормализации.
Реляционная модель поощряет нормализацию — процесс устранения повторяющихся данных путем их разделения по связанным таблицам. Это экономит место для хранения и, что важнее, обеспечивает единственную точку истины для каждого фрагмента данных. Если нужно обновить адрес клиента, это делается только в одном месте.
Противопоставление NoSQL: В NoSQL (особенно в документных базах) часто используется денормализация — данные дублируются в разных документах для ускорения чтения. Однако при обновлении этих данных приходится вносить изменения во множество мест, что усложняет логику и повышает риск рассогласованности.

- Зрелость, стабильность и экосистема.
SQL-системы существуют десятилетиями, они тщательно протестированы, обладают надежными механизмами репликации, бэкапов, безопасности и мониторинга. Вокруг них сформировалась огромная экосистема инструментов: от средств визуального проектирования и администрирования (например, ER-диаграммы) до мощных ORM и систем бизнес-аналитики (BI), которые "из коробки" понимают SQL.
Противопоставление NoSQL: Многие NoSQL-системы моложе, и их инструменты и лучшие практики могут быть менее развитыми. Подход к решению задач (например, обеспечению безопасности или построению репликации) может сильно отличаться от системы к системе.

2. Ключевое преимущество — снятие фундаментального ограничения "масштабируемость ИЛИ согласованность" и замена его на "масштабируемость И согласованность".


## Задание_4_Кластеры

Необходимо производить большое количество вычислений при работе с огромным количеством данных, под эту задачу выделено 1000 машин.
На основе какого критерия будете выбирать тип СУБД и какая модель распределённых вычислений здесь справится лучше всего и почему?

## Решение 4

Учитывая задачу ("огромные данные" + "большое количество вычислений") и масштаб (1000 машин), наиболее вероятная и эффективная архитектура будет выглядеть так:

1. СУБД для хранения: Колоночная СУБД (например, ClickHouse) или распределённое хранилище поверх HDFS или Amazon S3.
2. Модель вычислений: Apache Spark.

Почему эта связка оптимальна:

- Spark будет выступать как мощный, быстрый и универсальный вычислительный движок, который может читать данные напрямую из вашего хранилища (S3, HDFS, HBase, Cassandra).
- Он проведёт все необходимые сложные преобразования, агрегации и вычисления, используя память и CPU всех 1000 машин.
- Результаты вычислений можно либо записать обратно в хранилище, либо загрузить в колоночную СУБД (типа ClickHouse) для последующего выполнения быстрых интерактивных аналитических запросов.